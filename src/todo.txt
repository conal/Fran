                               To Do Items

                  Last modified Thu Oct 02 17:16:45 1997


- Better error messages from newBitmapDDSurface, etc.  For instance:
  newBitmapDDSurface: could not open file "fiddle.bmp".  I tried, but I
  didn't know how.

- keyPress should perhaps have VKey and Char alternatives.  For Char, it
  should be possible to get lower-case, control, etc.

- Specifying the upperLeft to the sprite engine has a weird artifact due
  to interpolation.  Try "disp (\u -> bigger wiggle circle)", which looks
  like it is slipping diagonally.  Part of the problem is that the source
  surface is not interpolated, while the upperLeft is.  If we went back to
  specifying the bbox center, center-symmetric would scale better, but
  what about non-symmetric ones?  See also wordy4.


- Non-black backgrounds for flipsprites.

- Negative scaling of flip sprites.  According to Jeff Noyle, "specify the
  DDBLT_MIRROR flags and leave your rect as normal."

- Fix problem with jerky time-transformed ImageB's.  See
  followMouseAndDelay and followMouseAndDelay' in tutorial.hs.

- Maybe switch tutorial to use white backgrounds, but how?

- Black text is very cool, because it's see-through!

- Test changing init window size and screenPixelsPerLength

- Reconsider liftings for functions that produce tuple values, such as
  point2XYCoords and factorTransform2.  It would be more convenient,
  though less consistent, to produce a tuple of behaviors.

- Stenciling.

- Non-uniform scale.

- Handle sound sharing gracefully.  Sometimes another application, say
  NetShow, will have grabbed the sound card before Fran could get it it,
  and Fran doesn't react gracefully.  You'll often see the reverse
  problem: after you've done your first graphics, so that OpenSpriteLib
  has gotten called, you won't hear anything .wav from your sound card
  from other applications until you quit Hugs.  This is a serious problem,
  but I think it mostly goes away with DirectX 5, assuming the competing
  program is using DirectX 5 as well.  For robustness sake, I should at
  least make OpenSpriteLib return some kind of error value to be treated
  as an IO Error.

- Maybe eliminate afterE in favor of the following

      residualB :: GBehavior bv => bv -> Behavior bv

  Then

      e `afterE` bv = e `snapshot` residualB bv

- Get transparency of flip-images with non-black backgrounds to work.

- Does lazy spritification make sense?  I'd like to put in bounding
  volumes and then rely on spritification to be lazy.  Then I can do
  infinite patterns again.

- Maybe rename "-=>" to "==>-", and in general use a trailing "-" in
  operator names just as "_" in alphabetic names. 

- filterE remaps event data and removes some occurrences.  Maybe replace
  by a simplified function: Event (Maybe a) -> Event a, to be used in
  conjunction with ==>.

- Fix the space leaks caused by the lazy patterns in afterE and snapshot.

- Find and fix the bug tickled by the general *$/untilB transformations in
  Behavior.hs.  Probably related to afterE, but I don't know.

- Hey!! Now that events have several occurrences, maybe some of the
  occurrences could be at the same time??  This seems an important
  improvement.  For instance, suppose a ball hits two walls simultaneously
  (a corner).

- Fix integral to use RK4.  

- Improve factoring so that untilB-related code is shared rather than
  replicated.

- Make events carry a start time, and re-implement startTime

- Add a rectangular trimming operation to ImageB and use for making a
  photo background in ..\demos\Mover.hs.

- Make condB belong to GBehavior.  For ImageB, we'll probably have to add
  a conditional sprite tree.

- Adjust operator precedences so we can chain all of the event modifiers:
  -=>, ==>, `afterE`, `snapshot`, etc.  They need to all be
  left-associative and of the same precedence.  See, e.g., whenSnap.  The
  .|. operator should be of lower precedence.

- Revisit integral and strictness of the accumulator.  If a fix is needed,
  it could be to return (force ynp1 `seq` (ynp1 : ys))

- Fix memory management of DD surfaces.  The Release done in
  SimpleSprite::SetSurface is probably wrong, since a surface can now be
  shared, thanks to dynamic constant folding.

- Other places marked with "###"

- Re-org the behavior/event modules a bit, renaming "Event.hs" to
  "EventPart1.hs" and "BehaviorEvent.hs" to "Event.hs", importing and
  re-exporting all of EventPart1.  Then most modules can just import
  Event.hs.

- Setting of surfaces and of transforms happens too soon.  Should happen
  at t', not t, but there's no interface for it.

- Push dynamic reactive constant folding all the way to display.

- Transformable3 for points and vectors

- startTime on Event is problematic.  There is no way of knowing, since we
  know only a lower bound for the first occurrence time.

- Use malloc pointers for DirectX objects: surfaces, sound buffers, frame
  hierarchies.

- Rework sprite trees to be more like ImageB type in some ways:

  + binary overlay;

  + UntilI sprite tree, with event time (initially infinite) and new
    sprite tree, optimized away on traversal when past;

  + empty sprite tree.

- Similarly, rework sprite engine simple behaviors, generalizing to
  piecewise-simple with subdivision, and adding an untilB.

- How to keep representation optimized?  Eliminate untilB after events.
  Also over/empty and mix/silence.  Have the traverser take a
  pointer-pointer argument saying where to store the optimized form if it
  changes.  This is like returning the rep but with the continuation
  argument saying where to store it.  Some cascading simplifications will
  probably take more than one pass, which is fine.  How to notice cases
  like over/empty?  I guess with hardwired methods like IsEmptyImage and
  IsSilence.  At the Haskell level, I'd probably put these optimizations
  into the ImageB and SoundB constructors, which seems very efficient.

  My current SpriteTree representation handles these optimizations
  quite naturally.  A good reason to stick with it.

- Continue with Asteroids game.

- Maybe change page number argument interpretation with a scale factor.
  Or, better yet, use time transformation.

- Logical <--> screen coordinate conversion.

- Unify SimpleImage and FlipImage somehow to eliminate redundancy.

