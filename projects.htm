<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>RBMH-Related Projects</TITLE>
<META NAME="Template" CONTENT="C:\Program Files\Microsoft Office\Office\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<P><!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"></P>
<H1 ALIGN="CENTER"><A HREF="http:./">Fran</A>-Related Projects</H1>
<H3 ALIGN="CENTER"><A HREF="http://www.research.microsoft.com/~conal">Conal Elliott</A></H3>
<EM><H3 ALIGN="CENTER">Last modified <!--webbot bot="TimeStamp"</H3>
startspan s-type="EDITED" s-format="%B %d, %Y" -->October 01, 1996<!--webbot
bot="TimeStamp" i-checksum="31567" endspan -->

<UL>
</EM><LI>A get-acquainted exercise: play with the prototype Haskell-based animation system Fran, developing small to medium-scale examples. Provide feedback on its features. </LI>
<LI>Help investigate and prototype alternate implementation approaches for improved efficiency. In particular, how can we represent behaviors so that they have the flexibility of functions of continuous time, but the caching-efficiency of (lazy) data structures? The representation must work correctly and efficiently even when a behavior is used more than once in another behavior (without differing time transforms). As an especially tricky but important case, consider systems of mutually recursive integrals (ordinary differential equations), which work in the current prototype, but extremely inefficiently. </LI>
<LI>Try to get great performance of Fran apps without any Fran-specific support in the compiler. Make a detailed study of Fran programs compiled under GHC, ranging from small to large. What are some of the significant perfomance issues and applicable optimization techniques? What applicable techniques are already in GHC implementations or could be easily added? What new optimization techniques arise out of this study? How to express and exploit domain-specific knowledge, such as abstract data type axioms (identities, commutativity, associativity, distributivity, etc). Does the approach scale with respect to both performance and programmability? </LI>
<LI>Haskell-based software components, integrating symmetrically with components implemented in other languages. (By "symmetrically", I mean no language technology insists on being "on top", at best deigning to call out via a foreign function interface.) For example, package up parameterized models as lightweight software components that can be very easily integrated into a COM setting, e.g., as ActiveX controls. Make it easy for users of Visual Basic, VBScript, Java, JavaScript, etc, to combine these components with each other and with more conventionally specified software components. Develop a user-assisted tool to generate COM/OLE/ActiveX interfaces to functionality implemented in Haskell. How to reconcile language disparities, such as (a) Haskell's very expressive type system vs COM's weak one; (b) Haskell types with bottom vs C-ish types without; Haskell's tupled and curried function arguments and tupled return values vs the C style. Do safe and efficient storage management, say via automatically reference counting COM objects that wrap GHC stable pointers. </LI>
<LI>Explore semantics for interactive models, starting with user/model interaction, and then more generally, model/model interactions (e.g., collisions and pursuit/avoidance). Can models be both interactive and spatio-temporally modular (transformable)? Simplify and generalize the current model. </LI></UL>
</BODY>
</HTML>
