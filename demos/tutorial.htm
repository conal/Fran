<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Template"
content="C:\Program Files\Microsoft Office\Office\html.dot">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<title>Composing Reactive Animations</title>
<!--                                Generated by Vulcanize v0.5 . -->
<!--                               Whom to blame: M-J. Dominus, mjd@pobox.com -->
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<p>&nbsp; </p>

<h1 align="center">Composing Reactive Animations </h1>

<h3 align="center"><a
href="http://www.research.microsoft.com/~conal/">Conal Elliott</a><br>
Microsoft Research<br>
Graphics Group </h3>

<h3 align="center">June, 1997 </h3>

<h5 align="center">Copyright <font face="Symbol">ã</font> 1997
Microsoft Research</h5>

<h1>Introduction</h1>

<p>We have all seen a lot of wonderful looking computer graphics,
and many of us have spent time playing video games or watching
our kids (or their kids) play them. It is clear that computer
graphics, especially interactive graphics, is an incredibly
expressive medium, with potential beyond our current imagination.</p>

<p>Affordable personal computers are capable of very impressive
2D animation and multi-media. Interactive 3D graphics is already
available, and soon it will be standard for new personal
computers. Thus, the raw materials for creating and sharing
interactive graphics are in reach of all of us.</p>

<p>That's the good news.</p>

<p>The bad news is that very few people are able to create their
own interactive graphics, and so what might otherwise be a widely
shared medium of communication is instead a tool for specialists.
The problem is that there are too many low-level details that
have to do not with the desired content -- e.g., shapes,
appearance and behavior -- but rather how to get a computer to <em>present</em>
the content. For instance, behaviors like motion and growth are
generally gradual, continuous phenomena. Moreover, many such
behaviors go on simultaneously. Computers, on the other hand,
cannot directly accommodate either of these basic properties,
because they do their work in discrete steps rather than
continuously, and they only do one thing at a time. Graphics
programmers have to spend much of their effort bridging the gap
between <em>what</em> an animation is and <em>how</em> to present
it on a computer.</p>

<p>One approach to solving this problem is to avoid programming
altogether, and instead use a visual authoring tool. These tools
are becoming quite powerful and reasonably easy to use, but they
are not nearly as flexible as programming, especially for <em>interactive</em>
content in which decisions have to be made dynamically.</p>

<p>If programming is necessary for the creation of interactive
content, but the kind of programming used to make such content
today is unsuitable for most of the potential authors, then we
need to move toward a different form of programming. This form
must give the author complete freedom of expression to say <em>what
an animation is</em>, while invisibly handling details of
discrete, sequential presentation. In other words, this form must
be <em>declarative</em> (&quot;what to be&quot;) rather than <em>imperative</em>
(&quot;how to do&quot;).</p>

<p>This article presents one approach to declarative programming
of interactive content, as realized in a prototype system called <i>Fran</i>
(Functional reactive animation) [<a href="#ElliottHudak97">Elliott
and Hudak 1997</a>]. Fran is a high level vocabulary that allows
one to describe the essential nature of an animated model, while
omitting details of presentation. Moreover, because this
vocabulary is embedded in a modern functional programming
language (Haskell), the animation models thus described are
reusable and composable in powerful ways.</p>

<p>I do not assume familiarity with Haskell, and have tried to
make this article mostly self-contained. This is hard to do well,
and requires that you take some of the details on faith for now.
See [<a href="#BirdWadler87">Bird and Wadler 1987</a>] and [<a
href="#HudakFasel92">Hudak and Fasel 1992</a>] for introductions
to functional programming in general and Haskell in particular
and [<a href="#HudakEtAl92">Hudak et al 1992</a>] for reference.</p>

<p>Fran is currently available, with all source code, as part of
the Hugs implementation of Haskell for Windows 95 and Windows NT,
which is freely available [<a href="#Hugs1Point4">Hugs 1.4</a>].</p>

<h1>Examples</h1>

<p>This article contains several animation examples to illustrate
our declarative approach to animation. Executable source code
appears as lines of text in <tt>this font</tt>. There are three
ways to experience this article, with increasing levels of
immersion.</p>

<ul>
    <li>In the printed version, each example has an accompanying
        sequence of tiny snapshots. By scanning them from left to
        right and top to bottom (first row, second row, etc), you
        will get some sense of motion. </li>
    <li>In the <a
        href="http://www.research.microsoft.com/~conal/Fran/tutorial.htm">World
        Wide Web version</a>, each example is illustrated by an
        animated GIF. This version shows the animations over
        time, but is not at all interactive. </li>
    <li>Finally, you can run the examples, and interact with
        them. In this case, you can even modify the definitions
        or add news ones, reload and have a new animation. After
        installing Hugs from [<a href="#Hugs1Point4">Hugs 1.4</a>],
        double-click on the file <tt>tutorial.hs</tt> in the
        subdirectory <tt>lib\Fran</tt>\demos. The examples will
        begin running automatically. Press space, &quot;n&quot;,
        or right-arrow to advance to the next animation, and
        &quot;p&quot; or left-arrow to back up to the previous
        one. If you want to display just a single animation,
        e.g., <tt>leftRightCharlotte</tt>, then close the
        animation window and type &quot;<tt>display
        leftRightCharlotte</tt>&quot; to the prompt. You can
        alter the definition in an editor, save the result, type
        &quot;<tt>:r</tt>&quot; to the Hugs prompt, and &quot;<tt>$$</tt>&quot;
        again to display the new version. For examples involving
        user interaction or rate-based animation, use <tt>displayT</tt>
        instead of <tt>display</tt>, as mentioned below. <i>[Note
        as of June 19, 1997, Hugs 1.4 has not yet been released,
        so these instructions do not work quite yet. Please email
        me if you would like to try Fran and do not find Fran or
        the examples.]</i></li>
</ul>

<h2>First example</h2>

<p>We'll start with a very simple animation, called <tt>leftRightCharlotte</tt>,
of Charlotte moving from side to side. </p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> leftRightCharlotte = moveXY wiggle 0 charlotte

 charlotte = importBitmap &quot;../Media/charlotte.bmp&quot;  </pre>
        </td>
        <td><p align="center"><img
        src="gifs/leftRightCharlotte.gif" width="200"
        height="220"></p>
        </td>
    </tr>
</table>
</center></div>

<p>This line defines a value called <tt>leftRightCharlotte</tt>
to be the result of applying the function <tt>moveXY</tt> to
three arguments. (In most other programming languages, you would
instead say something like &quot;<tt>moveXY(wiggle,0,charlotte)&quot;</tt>.)</p>

<p>The function <tt>moveXY</tt> takes <em>x</em> and <em>y</em>
values and an image, and produces an image moved horizontally by <em>x</em>
and vertically by <em>y</em>. All values may be animated. In this
example, the <em>x</em> value is given by a predefined smoothly
animated number called <tt>wiggle</tt>. Wiggle starts out at
zero, increases to one, decreases back past zero to negative one,
and then increases to zero again, all in the course of two
seconds, and then it repeats, forever.</p>

<p>The second line defines <tt>charlotte</tt> by importing a
bitmap file, making it available for use on the first line as the
second argument to <tt>moveXY</tt>.</p>

<p>Although this first example is not exactly a masterpiece, it
is a complete animation program in just two short lines!</p>

<p>Similarly, we can define an animation of Patrick moving up and
down:</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> upDownPat = moveXY 0 waggle pat

 pat = importBitmap &quot;../Media/pat.bmp&quot;  </pre>
        </td>
        <td><p align="center"><img src="gifs/upDownPat.gif"
        width="200" height="220"></p>
        </td>
    </tr>
</table>
</center></div>

<p>To get the vertical movement, we use a nonzero value for the
second argument to <tt>moveXY</tt>. Rather than using <tt>wiggle</tt>,
we use <tt>waggle</tt>, which is defined to be just like <tt>wiggle</tt>,
but delayed by a half second. In the next example, we will see
why this change is useful.</p>

<h2>Combining animations</h2>

<p>Next we move on to a simple animation that my daughter Becky
and I cooked up one evening. This one combines the two previous
examples.</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> charlottePatDance = 
   leftRightCharlotte `over` upDownPat  </pre>
        </td>
        <td><p align="center"><img
        src="gifs/charlottePatDance.gif" width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>The <tt>over</tt> operation glues two given animations
together, yielding a single animation, with the first one being
over the second. Because we used <tt>waggle</tt> for <tt>upDownPat</tt>,
in this new combined animation Pat is at the center when
charlotte is at her extremes and vice versa.</p>

<h2>Digression: models vs presentations</h2>

<p>To provide a contrast, here is a very rough sketch of the
steps one usually goes through to program an animation. </p>

<ul>
    <li>Allocate and initialize window, various drawing surfaces
        and bitmaps </li>
    <li><b>repeat</b> until quit: </li>
    <li><ul>
            <li>get time ( <em>t</em>) </li>
            <li>clear back buffer </li>
            <li><b>for each</b> sprite (back to front): </li>
            <li><ul>
                    <li>compute position, scale, etc. at <em>t</em>
                    </li>
                    <li>draw to back buffer </li>
                    <li>fast copy (&quot;blit&quot;) back buffer
                        to front </li>
                </ul>
            </li>
            <li>Flip back buffer to the screen </li>
        </ul>
    </li>
    <li>Deallocate bitmaps, drawing surfaces, window </li>
</ul>

<p>These steps are usually carried out with lots of tedious,
low-level code that you have to write yourself.</p>

<p>Most of this work is not about what the animation is, but how
to present it. In contrast, Fran programs are only about what the
animation is.</p>

<p>&nbsp;</p>

<h2>Composition</h2>

<p>&quot;Composition&quot; is the principle of putting together
simpler things to make more complex things, then putting these
together to make even more complex things, and so on. This
&quot;building block&quot; principle is crucial for making even
moderately complicated constructions; without it, the complexity
quickly becomes unmanageable.</p>

<p>The examples above illustrate composition. We first built <tt>leftRightCharlotte</tt>
out of <tt>charlotte</tt>, <tt>wiggle </tt>and <tt>moveXY</tt>;
then we built <tt>upDownPat</tt> out of <tt>pat</tt>, <tt>moveXY</tt>
and <tt>waggle</tt>; and finally we built <tt>charlottePatDance</tt>
out of <tt>leftRightCharlotte</tt> and <tt>upDownPat</tt>. A
crucial point here is that when we make something out of building
blocks (e.g., <tt>leftRightCharlotte</tt> or <tt>upDownPat</tt>,
the result is a new building block in itself, and we can forget
about how it was constructed.</p>

<p>There is a still more powerful version of composition, based
on defining functions. For example, let us now define a new
function called <tt>hvDance</tt> (for horizontally and vertical
dance), that can combine any two images, in the way that <tt>charlottePatDance</tt>
combines <tt>charlotte</tt> and <tt>pat</tt>:</p>

<pre>    hvDance im1 im2 =
      moveXY wiggle 0 im1  `over`
      moveXY 0 waggle im2</pre>

<p>Now we can give a new definition for our dancing couple that
gives exactly the same animation:</p>

<pre>    charlottePatDance = hvDance charlotte pat</pre>

<p>Having defined this generalized dance animation, we can go on
to more daring compositions. For example, we can take an
animation produced by <tt>hvDance</tt>, shrink it, and <i>put the
result back into</i> <tt>hvDance</tt> twice to make it dance with
itself. The result is pleasantly surprising. </p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> charlottePatDoubleDance = hvDance aSmall aSmall 
   where
    aSmall = smaller 2 charlottePatDance  </pre>
        </td>
        <td><p align="center"><img
        src="gifs/charlottePatDoubleDance.gif" width="200"
        height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>This example gives you a hint of how powerful it is to be able
to define new animation functions. The possibilities are
limitless, so I encourage you to apply your imagination and try
out more variations. Here are a few more, just to give you ideas.</p>

<p>We could try <tt>charlottePatDance</tt>, made bigger by a
wiggly amount. To prevent negative scaling, we take the absolute
value of <tt>wiggle</tt>. </p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> dance1 = bigger (abs wiggle) charlottePatDance </pre>
        </td>
        <td><p align="center"><img src="gifs/dance1.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>Next, use <tt>hvDance</tt> again, but give it wiggly-sized
charlotte and pat. This time, we haven't prevented negative
scaling. For visual balance, we use <tt>wiggle</tt> and <tt>waggle</tt>.
</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> dance2 = hvDance (bigger wiggle charlotte) 
                  (bigger waggle pat)</pre>
        </td>
        <td><p align="center"><img src="gifs/dance2.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>Next, put Pat in orbit around a growing and shrinking
charlotte. To get a circular motion, we use the <tt>moveXY</tt>
function, with <tt>wiggle</tt> for <em>x</em> and <tt>waggle</tt>
for <em>y</em>. </p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> patOrbitsCharlotte =
   bigger wiggle charlotte  `over` 
   moveXY wiggle waggle pat</pre>
        </td>
        <td><p align="center"><img
        src="gifs/patOrbitsCharlotte.gif" width="200"
        height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>By the way, if you remember your high school trigonometry,
you've probably surmised that <tt>wiggle</tt> and <tt>waggle</tt>
are related to sine and cosine. In fact, they can be defined very
simply, as follows:</p>

<pre>    wiggle = sin (pi * time)
    waggle = cos (pi * time)</pre>

<p>The animated number called <tt>time</tt> is a commonly used
&quot;seed&quot; for animations and has the value <i>t</i> at
time <i>t</i>. Thus, for instance, the value of <tt>wiggle</tt>
at time <i>t</i> is equal to sin<i> (</i><font face="Symbol"><i>p</i></font><i>
t)</i>.</p>

<h2>Rate-based animation</h2>

<p>In the previous examples, the positions of animations are
specified directly. For instance, the definition of <tt>leftRightCharlotte</tt>
says that Charlotte's horizontal position is <tt>wiggle</tt>.</p>

<p>In our physical universe, objects move as a consequence of
forces. As explained by Newton, force leads to acceleration,
acceleration to velocity, and velocity to position. With computer
animation, an author has the freedom to ignore the laws of our
universe. However, since animations are usually intended to be
viewed by and interacted with by inhabitants of our own universe,
they are often made to look and feel real by emulating the
Newtonian laws or simplifications and variations on them.</p>

<p>The key idea underlying Newton's laws and their variations is
the notion of an instantaneous rate of change, and so Fran makes
this notion available in animation programs. As a first, very
simple, illustration of rate-based animation, we can make Becky
move from the left edge of our viewing window, toward the right,
at a rate of one distance unit per second.</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> velBecky t0 = moveXY x 0 becky 
   where
     x = -1 + atRate 1 t0</pre>
        </td>
        <td><p align="center"><img src="gifs/velBecky.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>The local definition of <tt>x</tt> here (introduced as a
&quot;where clause&quot;), follows a style you will see in the
following few definitions. To express, a value that starts out
with a value <tt>x0</tt> and grows at a rate of <tt>r</tt>, one
says &quot;<tt>x0 + atRate r t0</tt>&quot;.</p>

<p>Rate-based animations, like this one, are functions of a
&quot;start time&quot;, here called <tt>t0</tt>, in order to give
<tt>atRate</tt> a way of knowing when to start. Unlike the
previous examples, this one can be displayed with the function <tt>displayT</tt>,
so to see this example, type &quot;<tt>displayT velBecky</tt>&quot;.
We will see other uses for this user argument below.</p>

<p>In the <tt>velBecky</tt> example, Becky has a constant
velocity, but with only a little more effort, we can give Becky a
constant acceleration instead, by providing a constant value for
the rate of change of the velocity.</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> accelBecky t0 = moveXY x 0 becky 
   where
     x = -1 + atRate v t0
     v =  0 + atRate 1 t0</pre>
        </td>
        <td><p align="center"><img src="gifs/accelBecky.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>In the definition of v, the &quot;<tt>0 +</tt>&quot; is
unnecessary, but emphasizes that the initial velocity is zero. </p>

<p>The notion of &quot;rate&quot; is useful not just in one
dimension, but in two and three dimensions as well. In the next
example, we will control Becky's two-dimensional velocity with
the mouse. When you hold the mouse cursor is at the center of the
view window, Becky will stay still. As you move away from the
center, imagine an arrow from the window's center to the mouse
cursor. Becky will be moving in that direction and her speed will
be equal to the arrow's length. This kind of imaginary arrow is
referred to as a <i>vector</i>, and is the type of quantity that
a two- or three-dimensional offset, velocity or acceleration is.
In 2D, a vector can be thought of as having horizontal and
vertical (<i>X</i> and <i>Y</i>) components, or as having a
magnitude (length) and direction.</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> mouseVelBecky t0 = move offset becky
   where
    offset = atRate (mouseMotion t0) t0 </pre>
        </td>
        <td><p align="center"><img src="gifs/mouseVelBecky.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>This time, we're using the function <tt>move</tt>, a variant
of <tt>moveXY</tt> that takes a 2D offset vector. (If a vector <tt>v</tt>
is <em>x</em> units horizontally and <em>y</em> units vertically,
then &quot;<tt>move v im</tt>&quot; is equivalent to &quot;<tt>moveXY
x y im</tt>&quot;). The offset vector starts out as zero, and
grows at a rate called <tt>vel</tt>, thanks to the <tt>atRate</tt>
function. The rate is equal to <tt>mouseMotion</tt>, which is the
offset of the mouse cursor relative to the origin of 2D space
(which we see at in the center of the view window). It takes the
user argument, which is how it when to start watching the mouse.</p>

<p>In the real world, the position of an object may affect its
speed or acceleration. In the next example, Becky is chasing the
mouse cursor. The further away he is, the faster she moves. </p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> beckyChaseMouse t0 = move offset becky 
   where
    offset = atRate vel t0
    vel    = mouseMotion t0 - offset</pre>
        </td>
        <td><p align="center"><img src="gifs/beckyChaseMouse.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>The only difference from the previous example is that the
velocity is determined by where the mouse cursor is <i>relative
to</i> Becky's own position, as indicated by the vector
subtraction.</p>

<p>Just for fun, we can generalize the <tt>beckyChaseMouse </tt>function
in the same way that <tt>hvDance</tt> generalized <tt>charlottePatDance</tt>
in an earlier example. </p>

<pre> chaseMouse im t0 = move offset im
   where
    offset = atRate vel t0
    vel    = mouseMotion t0 - offset</pre>

<p>Then &quot;<tt>chaseMouse becky</tt>&quot; is equivalent to <tt>beckyChaseMouse</tt>,
as you can verify by typing the following to the Hugs prompt:</p>

<pre>    displayT (chaseMouse becky)</pre>

<p>For more fun, try the same, but replacing <tt>becky</tt> by
some of the animations that appear earlier in this article, e.g.,
<tt>leftRightCharlotte</tt>, <tt>charlottePatDance</tt>, and <tt>patOrbitsCharlotte</tt>.</p>

<p>&nbsp;</p>

<p>Next let's make a chasing animation that acts like it is
attached to the mouse cursor by a spring. The definition is very
similar to <tt>beckyChaseMouse</tt>. This time, however, the rate
is itself changing at a rate we call <tt>accel</tt> (for
acceleration). This acceleration is defined like the velocity was
in the previous example, but this time we also add some drag that
tends to slow down Becky by adding some acceleration in the
direction opposite to her movement. (Increasing or decreasing the
&quot;drag factor&quot; of 0.5 below creates more or less drag.) </p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> springDragBecky t0 = move offset becky
   where
    offset = atRate rate t0
    vel    = atRate accel t0
    accel  = (mouseMotion t0 - offset) - 0.5 *^ vel </pre>
        </td>
        <td><p align="center"><img src="gifs/springDragBecky.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>The operator <tt>*^</tt> multiplies a number by a vector,
yielding a new vector that has the same direction as the given
one but a scaled magnitude.</p>

<p>As usual, these declarative animation programs are simple
because they say what the motion is, in high level, continuous
terms, without struggling to accommodate the discreteness of the
computer used to present them. In contrast, imperative animation
programs must explicitly <em>simulate</em> rate-based animation
by making lots of little discrete steps, accumulating
approximations to the continuously varying forces, accelerations,
and velocities, in order to approximate motion. Unfortunately,
doing an accurate and efficient job of all this approximation
work is a very tricky task. With a system like Fran, the author
just describes the continuous motion in terms of continuously
varying rates, and trusts to Fran to do a good job with the
approximation. (Not good enough to fly a real airplane or control
dangerous machinery, but good enough for a pleasant and effective
illustration or game.)</p>

<h2>Composition in time</h2>

<p>Operations like <tt>over</tt> and <tt>move</tt> support the
principle of <em>composition</em> in space. Composition in <em>time</em>
is equally valuable. As a first example, let's define an orbiting
animation, and then combine it with a version of itself delayed
by one second.</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> orbitAndLater = orbit `over` later 1 orbit 
   where
    orbit = moveXY wiggle waggle jake</pre>
        </td>
        <td><p align="center"><img src="gifs/orbitAndLater.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>Instead of delaying, we may want to slow it down.</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> orbitAndSlower = orbit `over` slower 2 orbit 
   where
    orbit = move wiggle waggle jake</pre>
        </td>
        <td><p align="center"><img src="gifs/orbitAndSlower.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>We can even delay or slow down animations involving user
input. In the following example, one Jake tracks the mouse
cursor, while the other follows the same path, but delayed by one
second.</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> followMouseAndDelay t0 =
   follow `over` delay 1 follow
    where
     follow = move (mouseMotion t0) jake </pre>
        </td>
        <td><p align="center"><img
        src="gifs/followMouseAndDelay.gif" width="200"
        height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>Next let's build an animated sentence, following the mouse's
motion path. As a preliminary step, define a function <tt>delayAnims</tt>,
which takes a time delay <tt>dt</tt> and a list <tt>anims</tt> of
animations, and yields an animation. Each successive member of
the given animation list is delayed by the given amount after the
previous member. </p>

<pre>    delayAnims dt anims =
      overs (zipWith later [0, dt ..] anims)</pre>

<p>This example introduces a few new elements. The Fran function <tt>overs</tt>
is like <tt>over</tt>, but it applies to a <i>list</i> of
animations rather than just two. Animations earlier in the list
are placed over ones later in the list. The notation <tt>[0, dt
...]</tt> means the infinite list of numbers 0, <i>dt</i>, 2 <i>dt</i>,
3 <i>dt</i>, etc. Finally, the function <tt>zipWith</tt> applies
a given two argument function the successive values from two
given lists. We use it here to delay the first animation in <tt>anims</tt>
by 0 seconds, the second by <i>dt</i> seconds, the third by 2 <i>dt</i>
seconds, etc. Finally, <tt>overs</tt> combines them into a single
animation.</p>

<p>Next, use <tt>delayAnims</tt>, to define a function <tt>mouseTrailWords</tt>
that to make our animated sentences.</p>

<pre>    trailWords motion str =
      delayAnims 1 (map moveWord (words str))
      where
        moveWord word = move motion (
                         bigger 2 (
                           withColor blue (stringIm word) )) </pre>

<p>A few words of explanation are in order. The Haskell function <tt>words</tt>
takes a string apart into a list of separate words. The Haskell
function <tt>map</tt> takes a function (here <tt>moveWord</tt>)
and a list of values (here the separated words) and makes a new
list by applying the function to each member of the list. The
Fran function <tt>stringIm</tt> makes a picture of a string. We
define the function <tt>moveWord</tt> locally to be the result of
making a picture of the given word, using the Fran function <tt>stringIm</tt>,
and moving it to follow the mouse. The function <tt>delayAnims</tt>,
defined above, then causes each of these mouse-following word
pictures to be delayed by different amounts.</p>

<p>Here is one use of <tt>trailWords</tt>:</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> flows t0 = trailWords motion
              &quot;Time flows like a river&quot;
   where
     motion = 0.7 *^ vector2XY (cos time)
                               (sin (2 * time)) </pre>
        </td>
        <td><p align="center"><img src="gifs/flows.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>Here is another, this time following the mouse:</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> flows2 t0 =
  trailWords (mouseMotion t0) 
      &quot;Time flows like a river&quot; </pre>
        </td>
        <td><p align="center"><img src="gifs/flows2.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<h2>A reactive animation</h2>

<p>The animations above are all what might be called
&quot;non-reactive&quot;, meaning that they are always doing the
same thing. A &quot;reactive animation&quot; is one involving
discrete changes, due to events. As a very simple example, we
make a circle whose color starts off red and changes to blue when
the left mouse button is first pressed. (Note: the animated
figure below is made to repeat, so that you do not miss the
transition, but when run, the animation really changes color only
once.)</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> redBlue t0 = withColor c circle
   where
    c = red `untilB` lbp t0 -=&gt; blue </pre>
        </td>
        <td><p align="center"><img src="gifs/redBlue.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>An informal reading of the last line is that the color <tt>c</tt>
is red until the user presses the left mouse button, and them
becomes blue. </p>

<p>For a more literal reading of this example, one must
understand that there are really two new binary infix operators
here, <tt>untilB</tt> and &quot;<tt>-=&gt;</tt>&quot;, which can
be used separately or together. The implied parentheses are
around &quot;<tt>lbp t0 -=&gt; blue</tt>&quot;. The &quot;<tt>-=&gt;</tt>&quot;
operator, which can be read as &quot;handled by value&quot; takes
an <i>event</i> (here <tt>lbp t0</tt>) and a value (here <tt>blue</tt>),
and yields a new event. In this case, the new event happens when
the left button is pressed, and has value <tt>blue</tt>. The <tt>untilB</tt>
operator takes an animation of any type (here the color-valued
constant animation <tt>red</tt>), and an event (here &quot;<tt>lbp
t0 -=&gt; blue</tt>&quot;), whose occurrence provides a new
animation of the same type. (Formal definitions of the notion of <i>event</i>
and the meanings of these operators are in Elliott and Hudak
1997.)</p>

<h2>Cyclic reactivity</h2>

<p>To make the previous example more interesting, let's switch
between red and blue every time the left button is pressed. We
accomplish this change with the help of a function <tt>cycle</tt>
that takes two colors, <tt>c1 </tt>and <tt>c2</tt>, and gives an
animated color that starts out as <tt>c1</tt>. When the button is
pressed, it swaps <tt>c1</tt> and <tt>c2</tt> and repeats (using
recursion). </p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> redBlueCycle t0 = withColor (cycle red blue t0) circle 
   where
    cycle c1 c2 t0 =
     c1 `untilB` lbp t0 *=&gt; cycle c2 c1</pre>
        </td>
        <td><p align="center"><img src="gifs/redBlueCycle.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>This time, we have used the operator &quot;<tt>*=&gt;</tt>&quot;,
which is a variant of &quot;<tt>-=&gt;</tt>&quot;. This new
operator, which can be read as &quot;handled with time&quot;
takes an event and a function <i>f</i>. It works just like &quot;<tt>-=&gt;</tt>&quot;,
but gets an event value by applying <i>f</i> to the given event's
time of occurrence. In this case, the function <i>f</i> is our <tt>cycle</tt>
function applied to just two arguments, leaving the third one
(the event time) to be filled in automatically <tt>*=&gt;</tt>.
Note, however, that the color arguments get swapped each time
&quot;around the loop&quot;. </p>

<p>Just to show some more variety, let's now use three colors,
and have the circle's size change smoothly. </p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> tricycle t0 =
    withColor (cycle3 green yellow red t0) ( 
      bigger (wiggleRange 0.5 1)
        circle )
   where
    cycle3 c1 c2 c3 t0 =
     c1 `untilB` lbp t0 *=&gt; cycle3 c2 c3 c1</pre>
        </td>
        <td><p align="center"><img src="gifs/tricycle.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<h2>Choice</h2>

<p>The next example is a flower that starts out in the center,
and moves to left or right when the left or right mouse button is
pressed, returning to the center when the button is released. </p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> jumpFlower t0 = moveXY (bSign t0) 0 flower

 flower = importBitmap &quot;../Media/flwrblu.bmp&quot;  

 bSign t0 = 
  0 `untilB` 
    lbp t0 *=&gt; nonZero (-1) lbr .|. 
    rbp t0 *=&gt; nonZero 1    rbr 
  where 
   nonZero r stop t0 = 
    r `untilB` stop t1 *=&gt; bSign</pre>
        </td>
        <td><p align="center"><img src="gifs/jumpFlower.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>What's different here is that when the flower is in the
middle, it is interested in two events at the same time. This
simultaneous interest is indicated by the <tt>.|.</tt> operator
in the definition of <tt>bSign</tt> above. Pressing the left (or
right) button after t0 leads to a behavior generated by <tt>nonZero</tt>,
which will be -1 (or 1) until the left (or right) button is
released, at which time we switch back to <tt>bSign</tt>, but
with a start time equal to the button release event time
(supplied by <tt>*=&gt;</tt>). </p>

<p>We can use the function <tt>bSign</tt> above to control the
rate of growth of an image. Pressing the left (or right) button
causes the image to shrink (or grow) until released. Put another
way, the rate of growth is 0, -1, or 1, according to <tt>bSign</tt>.
</p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> growFlower = grow flower

 grow im t0 = bigger size im  
  where 
   size = 1 + atRate rate t0 
   rate = bSign t0 </pre>
        </td>
        <td><p align="center"><img src="gifs/growFlower.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>A very simple change to the <tt>grow</tt> function above
causes the image to grow or shrink at a rate equal to its own
size. </p>
<div align="center"><center>

<table border="1" cellspacing="1" bordercolor="#000080">
    <tr>
        <td><pre> growFlowerExp = grow' flower 

 grow' im t0 = bigger size im  
  where 
   size = 1 + atRate rate t0 
   rate = bSign t0 * size </pre>
        </td>
        <td><p align="center"><img src="gifs/growFlowerExp.gif"
        width="200" height="200"></p>
        </td>
    </tr>
</table>
</center></div>

<p>&nbsp;</p>

<h1>Conclusions</h1>

<p>The availability and affordability of graphics and multimedia
on personal computers offers the possibility of an exciting new
interactive medium. Before this hope can be realized, however,
the process of constructing interactive content must be made much
easier. While non-programming authoring tools help a good deal,
they significantly restrict expressiveness. For this reason, it
is worth pursuing a move from <em>imperative</em> to <em>declarative</em>
programming of interactive content. The prototype system Fran is
step in this pursuit, augmenting the language Haskell with a high
level collection of building blocks for composing reactive
animations. </p>

<p>&nbsp;</p>

<h1>Related Work</h1>

<p>My own inspiration for functional animation came from Kavi
Arya's work [<a href="#Arya86">Arya 1986</a>]. This work was
elegant, but used a discrete model of time. The <em>TBAG</em>
system used a continuous time model, and had a similar syntactic
flavor [<a href="#ElliottEtAl94">Elliott et al 1994</a>]. Unlike
Fran, however, reactivity was handled imperatively. Behaviors
were created by means of constraint solving and (destructively)
replaced through constraint assertion and retraction. <em>Concurrent
ML</em> introduced a first-class notion of &quot;events&quot; [<a
href="#Reppy91">Reppy 1991</a>] that can be constructed
compositionally. However, those events perform side-effects such
as writing to buffers or removing data from buffers. In contrast
Fran event occurrences have associated values; they help define
what an animation <em>is</em>, but do not cause any side-effects.
See [<a href="#ElliottHudak97">Elliott and Hudak 1997</a>] for
many more references. </p>

<h1>Future Work</h1>

<p>There are many opportunities to improve on the work described
in this article, including sound and 3D animation, as in [<a
href="#ElliottEtAl94">Elliott et al 1994</a>]; efficiency
improvements by mapping animations onto sprite-based display
architectures such as [<a href="#TorborgKajiya96">Torborg and
Kajiya 1996</a>]; generation of animation &quot;software
components&quot; to integrate with components written in more
mainstream programming languages; support for distributed,
multi-user scenarios; use of constraints, but handling reactivity
declaratively instead of with side-effects. </p>

<p>&nbsp;</p>

<h1>Acknowledgements</h1>

<p>Todd Knoblock and Jim Kajiya helped to explore the basic ideas
of behaviors and events. Sigbjorn Finne helped a lot with the
implementation during a summer research internship. Alastair Reid
made many improvements to the Haskell code. Paul Hudak, Alastair
Reid, and John Peterson at Yale provided many helpful discussions
about functional animation, how to use Haskell well, and lazy
functional programming in general. </p>

<p>&nbsp;</p>

<h1>Bibliography</h1>

<p><a name="Arya86"></a>Kavi Arya. A Functional Approach to
Animation. <i>Computer Graphics Forum</i>, 5(4):297-311, December
1986.</p>

<p><a name="BirdWadler87"></a>Robert Bird and Philip Wadler, <i>Introduction
to Functional Programming</i>, Prentice-Hall, International
Series in Computer Science, 1987.</p>

<p><a name="ElliottComposingHTML97"></a>Conal Elliott, Composing
Reactive Animations (<a
href="http://www.research.microsoft.com/~conal/Fran/tutorial.htm">HTML
version</a>), 1997.</p>

<p><a name="ElliottHudak97"></a>Conal Elliott and Paul Hudak,
Functional Reactive Animation. In <i>Proceedings of the 1997 ACM
SIGPLAN International Conference on Functional Programming</i>,
June, 1997. Available as <a
href="http://www.research.microsoft.com/~conal/papers/icfp97.ps">postscript</a>.</p>

<p><a name="ElliottEtAl94"></a>Conal Elliott, Greg Schechter,
Ricky Yeung and Salim Abi-Ezzi, TBAG: A High Level Framework for
Interactive, Animated 3D Graphics Applications. In Andrew
Glassner, editor, <i>Proceedings of SIGGRAPH '94 (Orlando,
Florida)</i>, pages 421-434. ACM Press, July, 1994. Available as <a
href="http://www.research.microsoft.com/~conal/tbag/papers/siggraph94.ps">postscript</a>.</p>

<p><a name="HudakFasel92"></a>Paul Hudak and Joseph H. Fasel, A
gentle introduction to Haskell. SIGPLAN Notices, 27(5), May 1992.
See <a href="http://haskell.org/tutorial/index.html">http://haskell.org/tutorial/index.html</a>
for latest version.</p>

<p><a name="HudakEtAl92"></a>Paul Hudak, Simon L. Peyton Jones,
and Philip Wadler (editors), Report on the Programming Language
Haskell, A Non-strict Purely Functional Language (Version 1.2). <i>SIGPLAN
Notices</i>, March, 1992. See <a
href="http://haskell.org/report/index.html">http://haskell.org/report/index.html</a>
for latest version.</p>

<p><a name="Reppy91"></a>John H. Reppy, CML: A Higher-order
Concurrent Language. <i>Proceedings of the ACM SIGPLAN '91
Conference on Programming Language Design and Implementation</i>,
pages 293-305, 1991.</p>

<p><a name="TorborgKajiya96"></a>Jay Torborg and James T. Kajiya,
Talisman: Commodity Realtime 3D Graphics for the PC, <i>Computer
Graphics</i>, 30 (Annual Conference Series): 353-364, 1996.
Available in <a
href="http://www.research.microsoft.com/SIGGRAPH96/Talisman/">several
formats</a>.</p>

<p><a name="Hugs1Point4"></a>Yale University and Nottingham
University, <i>Hugs - The Haskell User's Gofer System, version
1.4</i>, 1997. <a href="http://www.haskell.org/hugs">Available on
the WWW</a>.</p>

<p>&nbsp;</p>
</body>
</html>
