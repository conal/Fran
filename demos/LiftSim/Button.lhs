

		Button.lhs

		Simon Thompson
	
		March 1998
	
A button is something which is sensitive to events when the mouse is in
the area covered by the button. This module provides the means for
implementing single buttons and blocks of buttons.

A button gives an ImageB together with a stream of messages generated by
its being activated. Also supplied as parameters are the event which
will deactivate the button and also the geometry of the button, that is
the area it occupies.

See the module TwoFloorSimButton for an example of use of buttonBlock.

>	module Button where

>	import Fran
>	import qualified StaticTypes as P 

The Geometry of a rectangle: bottom left and top right corners.

>	type Geom  = ((Double,Double),(Double,Double))
>	type GeomB = ((RealB,RealB),(RealB,RealB))

>	geomToGeomB :: Geom -> GeomB

>	geomToGeomB ((x1,y1),(x2,y2)) 
>	  = ((constantB x1,constantB y1),(constantB x2,constantB y2))

Colours for the components of the buttons

>	borderCol = red
>	unSetCol  = black
>	setCol    = blue
>	textCol   = green

The border for a button of given Geometry (note: need to place the frame
*over* the contents)

>	border :: Geom -> ImageB

>	border geom
>	    = withColor borderCol $ 
>	 		polyline [ point2XY x1 y1 , 
>		      		   point2XY x1 y2 ,  
>		      		   point2XY x2 y2 ,
>		      		   point2XY x2 y1 ,
>		      		   point2XY x1 y1 ]
>	    where
>	    ((x1,y1),(x2,y2)) = geomToGeomB geom

Drawing a rectangle; specify bottom left and top right points as pairs
of reals.

>	background :: Geom -> ImageB

>	background geom
>	  = polygon [ point2XY x1 y1 , 
>		      point2XY x1 y2 ,  
>		      point2XY x2 y2 ,  
>		      point2XY x2 y1 ]
>	    where
>	    ((x1,y1),(x2,y2)) = geomToGeomB geom


Produce the ImageB of the button, given its text, position and background
colour.

>	buttonView :: String -> Geom -> ColorB -> ImageB

>	buttonView str geom color
>	  = border geom 
>	    `over`
>	    moveXY centreX centreY (withColor textCol (stringIm str)) 
>	    `over`
>  	    withColor color (background geom)
>	    where
>	    ((x1,y1),(x2,y2)) = geomToGeomB geom
>	    centreX = (x1+x2)/2
>	    centreY = (y1+y2)/2

The button itself. Note that the User -> Event () argument supplies the 
actions (such as lbp) which are to activate the button, *if* the mouse is in the
appropriate position. As a result of the function we get the stream of
these successful activations (those activations of lbp at which the mouse is in the 
appropriate area).

>	button :: String -> 			-- text to be displayed
>		  Geom ->  			-- the Geom of the button
>		  (User -> Event ()) ->  	-- the set events which are
>						-- assumed to be user generated
>		  Event () ->  			-- the unset events  
>		  a ->				-- value returned on set
>		  User ->			-- input
>		  (ImageB,Event a)		-- the image of the button
>						-- plus
>						-- the stream of set events


>	button str geom setEv unSetEv setVal u
>	  = ( switcher unSetView 
>		       (setInArea -=> setView .|. unSetEv -=> unSetView),
>	      setInArea -=> setVal
>	    )
>	    where
>	    setView   = buttonView str geom setCol
>	    unSetView = buttonView str geom unSetCol
>	    setInArea = whenSnap (setEv u) (mouse u) (inArea geom)

Is a Point2B in the area given by a Geom? Used in checking whether a
mouse click is within a given button. Function used in button above.
Note the import of Point2 by means of the qualified import as above.

>	inArea :: Geom -> a -> P.Point2 -> Bool

>	inArea ((x1,y1),(x2,y2)) _ pt2
>	  = (x1 <= x) && (x <= x2) && (y1 <= y) && (y <= y2)
>	    where
>	    (x,y) = P.point2XYCoords pt2

A block of buttons, all responding to the same input event but at
different mouse positions. Returns both the graphical image and the
event stream generated the events according to the position of the mouse
at the event. The buttons are placed in a vertical tower, with the first
button in the list at the bottom of the tower.

>	buttonBlock :: Geom ->			-- of the bottom button
>		       [(String,Event (),a)] ->	-- the text items and
>						-- corresponding reset events
>		       (User -> Event ()) ->	-- input event
>		       User ->			-- input
>		       (ImageB,Event a)

>	buttonBlock _ [] _ _ = (emptyImage,neverE)

> 	buttonBlock geom [(str,unSetEv,setVal)] setEv  u
>	  = button str geom setEv unSetEv setVal u

>	buttonBlock geom ((str,unSetEv,setVal):rest) setEv u 
>	  = ( imageRest   
>	      `over`
>	      imageFirst , 
>	      eventRest 
>	      .|.
>	      eventFirst
>	    )
>	    where
>	    ((x1,y1),(x2,y2)) = geom
>	    geom' = ((x1,y2),(x2,y2+dy))
>	    dy = y2-y1
>	    (imageFirst,eventFirst) 
>		= button str geom setEv unSetEv setVal u
>	    (imageRest,eventRest)
>		= buttonBlock geom' rest setEv u

Testing

>	testBlock :: User -> ImageB

>	testBlock u = fst (buttonBlock ((0,0),(0.5,0.3))
>		 		       [("Up",rbp u,0),("Down",rbp u,1)]
>				       lbp
>				       u)
